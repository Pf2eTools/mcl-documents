import os
import subprocess
import json

COMMIT_HASH = subprocess.check_output(['git', 'rev-parse', 'HEAD']).decode('ascii').strip()
REPO_ULR = f"https://raw.githubusercontent.com/Pf2eTools/mcl-documents/{COMMIT_HASH}"
tactics_back_url = f"{REPO_ULR}/assets/tacticsback.png"


def get_bundled_lua(root):
    bundle_cmd = f'luabundler bundle ../lua/{root} -p "../?.lua"'
    return subprocess.check_output(bundle_cmd, shell=True)


def build_deck_from_dir(directory, back_url=None):
    deck = []
    files = os.listdir(directory)
    for img in files:
        if img.split(".")[-2].endswith("_b"):
            if img.replace("_b.", ".") not in files:
                print(f"WARNING: {img} is missing cardface!")
            continue

        file_type = img.split(".")[-1]
        card = {
            "name": ".".join(img.split(".")[:1]),
            "face": f"{REPO_ULR}/{directory.lstrip('../')}/{img}",
        }
        back_img = img.replace(f".{file_type}", f"_b.{file_type}")
        if back_img in files:
            card["back"] = f"{REPO_ULR}/{directory.lstrip('../')}/{back_img}"
        elif type(back_url) is str:
            card["back"] = back_url
        elif callable(back_url):
            card["back"] = back_url(card)
        deck.append(card)

    return deck


def card_to_lua_str(card):
    out = "{"
    out += ", ".join([f'{k} = "{v}"' for k, v in card.items()])
    out += "}"
    return out


def deck_to_lua_str(deck):
    out = "\n\t{\n\t\t"
    cards = [card_to_lua_str(c) for c in deck]
    out += ",\n\t\t".join(cards)
    out += "\n\t},"
    return out


def build_mcl_lua():
    LUA = ""
    castle_deck = build_deck_from_dir("../assets/castles")
    LUA += deck_to_lua_str(castle_deck)

    def get_siege_back(card):
        if card["name"].startswith("sa"):
            return f"{REPO_ULR}/assets/siege/sa_b.png"
        elif card["name"].startswith("sd"):
            return f"{REPO_ULR}/assets/siege/sd_b.png"
        return None

    siege_deck = build_deck_from_dir("../assets/siege", back_url=get_siege_back)
    LUA += deck_to_lua_str(siege_deck)

    veteran_deck = build_deck_from_dir("../assets/veteran")
    LUA += deck_to_lua_str(veteran_deck)

    warmachine_deck = build_deck_from_dir("../assets/warmachines")
    LUA += deck_to_lua_str(warmachine_deck)

    return LUA


def build_targ_lua():
    LUA = ""
    targ_deck = build_deck_from_dir("../assets/loyalist-targ", back_url=tactics_back_url)
    LUA += deck_to_lua_str(targ_deck)

    return LUA


def build_bara_lua():
    LUA = ""
    bara_deck = build_deck_from_dir("../assets/rebel-bara", back_url=tactics_back_url)
    LUA += deck_to_lua_str(bara_deck)

    return LUA


def build_2026(basepath):
    LUA = ""
    for faction in os.listdir(basepath):
        if faction == "game":
            game_deck = build_deck_from_dir(f"{basepath}/{faction}")
            LUA += deck_to_lua_str(game_deck)
            continue

        tactics_deck = build_deck_from_dir(f"{basepath}/{faction}/tactics", back_url=tactics_back_url)
        LUA += deck_to_lua_str(tactics_deck)

        attachments_deck = build_deck_from_dir(f"{basepath}/{faction}/attachments")
        LUA += deck_to_lua_str(attachments_deck)

        ncu_deck = build_deck_from_dir(f"{basepath}/{faction}/ncu")
        LUA += deck_to_lua_str(ncu_deck)

        units_deck = build_deck_from_dir(f"{basepath}/{faction}/units")
        LUA += deck_to_lua_str(units_deck)

    return LUA


def build_decks_lua(lua, file_path):
    LUA = f"-- THIS FILE WAS GENERATED BY scripts/build-spawn-decks.py\n"
    LUA += f"-- ALL MANUAL CHANGES WILL BE LOST THE NEXT TIME THIS FILE IS GENERATED!\n\n"

    LUA += "return {"
    LUA += lua
    LUA += "\n}"

    with open(file_path, "w", encoding="utf-8") as lua_file:
        lua_file.write(LUA)


def build_spawn_decks_json(lua_file, json_file):
    with open(f"../lua/spawn-decks-base.lua", "r", encoding="utf-8") as f:
        lua = f.read()

    with open("../lua/temp.lua", "w", encoding="utf-8") as f:
        temp = f'local decks = require("lua.{lua_file}")\n' + lua
        f.write(temp)

    bundle = get_bundled_lua("temp.lua")
    with open(f"../tts/tts-base.json", "r", encoding="utf-8") as f:
        save = json.load(f)

    save["ObjectStates"][0]["LuaScript"] = str(bundle, encoding="utf-8")

    with open(f"../tts/{json_file}", "w", encoding="utf-8") as f:
        json.dump(save, f, indent=4)

    os.remove(f"../lua/temp.lua")


def build_index(index):
    LUA = f"-- THIS FILE WAS GENERATED BY scripts/build-spawn-decks.py\n"
    LUA += f"-- ALL MANUAL CHANGES WILL BE LOST THE NEXT TIME THIS FILE IS GENERATED!\n\n"

    LUA += f'local commitHash = "{COMMIT_HASH}"\n'
    LUA += "local index = {\n"
    for index_item in index.values():
        LUA += "\t{ "
        kv_pairs = []
        for key, value in index_item.items():
            kv_pairs.append(f'{key} = "{value}"')
        LUA += ", ".join(kv_pairs)
        LUA += " },\n"
    LUA += "}"
    with open(f"../lua/index.lua", "w", encoding="utf-8") as lua_file:
        lua_file.write(LUA)


def main():
    index = {}
    mcl_lua = build_mcl_lua()
    lua_file_mcl = "mcl-decks.lua"
    build_decks_lua(mcl_lua, f"../lua/{lua_file_mcl}")
    build_spawn_decks_json("mcl-decks", "spawn-mcl-decks-button.json")
    index["mcl-decks"] = {"name": "Milestone Campaign League", "path": lua_file_mcl, "category": "custom"}

    # targ_lua = build_targ_lua()
    # build_decks_lua(targ_lua, "../lua/targ-decks.lua")
    # build_spawn_decks_json("targ-decks", "spawn-targ-decks-button.json")
    #
    # bara_lua = build_bara_lua()
    # build_decks_lua(bara_lua, "../lua/bara-decks.lua")
    # build_spawn_decks_json("bara-decks", "spawn-bara-decks-button.json")

    basepath_2026 = "../assets/2026"
    for version in os.listdir(basepath_2026):
        basepath = f"{basepath_2026}/{version}"
        lua_file_2026 = f"2026-{version}.lua"
        index[f"2026-{version}"] = {"name": f"2026 Playtest ({version})", "path": lua_file_2026, "category": "playtest"}
        build_decks_lua(build_2026(basepath), f"../lua/{lua_file_2026}")

    build_index(index)


if __name__ == "__main__":
    main()
